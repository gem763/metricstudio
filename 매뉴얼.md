# stay_cooldown_mask 매뉴얼

## 1. 개념

`stay_cooldown_mask`는 신호 마스크(`0/1`)에 대해 아래 두 단계를 순서대로 적용합니다.

1. `stay`: 연속 유지 조건 적용
2. `cooldown`: 출현 간격 조건 적용

핵심 정의는 아래와 같습니다.

```text
stay_cooldown_mask(x, s, c) = cooldown_mask(stay_mask(x, s), c)
```

- `x`: 원본 신호 마스크 (`True/False` 또는 `1/0`)
- `s`: stay_days (연속 최소 일수)
- `c`: cooldown_days (신호 간 최소 간격)

## 2. 구성 함수 의미

### 2.1 `stay_mask(x, s)`

- `x`가 `1`인 구간 중, 연속 길이가 `s` 이상인 지점만 `1`로 남깁니다.
- `s=1`이면 원본 `x`와 동일합니다.

### 2.2 `cooldown_mask(x, c)`

- `1`이 발생하면, 이후 `c`일 동안의 `1`은 `0`으로 차단합니다.
- `c=0`이면 입력과 동일합니다.

## 3. 반드시 성립하는 관계

정의상 아래 두 식은 항상 성립합니다.

```text
stay_cooldown_mask(x, s, 0) = stay_mask(x, s)
stay_cooldown_mask(x, 1, c) = cooldown_mask(x, c)
```

## 4. 사례 (0/1 기준)

아래에서는 보기 쉽게 `0/1`로 표기합니다.

### 사례 A: `s=1`, `c=2`

- 입력 `x`: `0 0 1 1 1 0 1 1 0 0`
- `stay_mask(x,1)`: `0 0 1 1 1 0 1 1 0 0`
- `cooldown_mask(...,2)`: `0 0 1 0 0 0 1 0 0 0`
- 최종 `stay_cooldown_mask(x,1,2)`: `0 0 1 0 0 0 1 0 0 0`

설명:
- `s=1`이므로 stay는 변화가 없고, cooldown만 적용된 결과가 됩니다.

### 사례 B: `s=2`, `c=0`

- 입력 `x`: `0 0 1 1 1 0 1 1 0 0`
- `stay_mask(x,2)`: `0 0 0 1 1 0 0 1 0 0`
- `cooldown_mask(...,0)`: `0 0 0 1 1 0 0 1 0 0`
- 최종 `stay_cooldown_mask(x,2,0)`: `0 0 0 1 1 0 0 1 0 0`

설명:
- `c=0`이므로 cooldown은 변화가 없고, stay 결과가 그대로 최종 결과가 됩니다.

### 사례 C: `s=2`, `c=2`

- 입력 `x`: `0 0 1 1 1 0 1 1 0 0`
- `stay_mask(x,2)`: `0 0 0 1 1 0 0 1 0 0`
- `cooldown_mask(...,2)`: `0 0 0 1 0 0 0 1 0 0`
- 최종 `stay_cooldown_mask(x,2,2)`: `0 0 0 1 0 0 0 1 0 0`

설명:
- 먼저 stay로 연속 2일 이상 지점을 만든 뒤, 남은 신호에 cooldown 간격을 적용합니다.

### 사례 D: `s=3`, `c=3`

- 입력 `x`: `0 1 1 1 0 1 1 1 1 0`
- `stay_mask(x,3)`: `0 0 0 1 0 0 0 1 1 0`
- `cooldown_mask(...,3)`: `0 0 0 1 0 0 0 1 0 0`
- 최종 `stay_cooldown_mask(x,3,3)`: `0 0 0 1 0 0 0 1 0 0`

## 5. 실무 해석 팁

- `s`를 키우면: 더 "지속적인" 조건만 남습니다.
- `c`를 키우면: 신호 간격이 넓어져 과도한 연속 신호를 줄일 수 있습니다.
- 먼저 stay를 적용하고 나서 cooldown을 적용하므로, 해석 순서가 직관적입니다.
